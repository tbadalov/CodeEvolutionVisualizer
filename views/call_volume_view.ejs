<html>
  <head>
    <style>
      * {
        padding: 0;
        margin: 0;
      }

      html, body, header {
        min-height: 100%;
        width: 100%;
        height: 100%;
      }
      
      #container {
        height: calc(100% - 40px);
        padding: 20px;
        position: relative;
      }

      #flexbox {
        display: flex;
        justify-content: stretch;
        flex: 0 0 0;
        height: 100%;
      }

      #leftMenu {
        background-color: #ccc;
        display: block;
        max-width: 25%;
      }

      #rightMenu {
        height: 100%;
        width: 100%;
        background-color: #ddd;
        overflow: scroll;
      }

      #selector {
        width: 0;
        height: 0;
        background-color: rgba(50, 200, 211, 0.5);
        position: absolute;
      }
    </style>
    <script src="https://unpkg.com/konva@7.0.3/konva.min.js"></script>
  </head>
  <body>
    <div id="container">
      <div id="flexbox">
        <div id="leftMenu">
        </div>
        <div id="rightMenu">
        </div>
      </div>
    </div>
    <div id="selector"></div>
  </body>
  <script>
    const scale = 5;
    const circleMarginX = 6;
    const circleMarginY = 4;
    const strokeWidth = 0;
    const pipeAngleRadius = 4;
    const floorMargin = 10;
    const stemLength = 10;
    const stemWidth = 6;
    var width = 1600;
    var height = 1000;
    const centerX = width / 5;
    const centerY = 0;
    const marginTop = 0;
    const trunkHeight = 45; //todo remove and use INITIAL_TRUNK_HEIGHT
    const INITIAL_TRUNK_HEIGHT = 45;
    const FLOOR_MARGIN_VERTICAL = 2;
    const INIT_STEM_LENGTH = 10;
    const floors = [];

    class CallVolumeDiagramPositioner {
      constructor(classesArray) {
        this.classesArray = classesArray;
        this.trunkHeightCache = new Array(classesArray.length);
        this.branchXCache = new Array(classesArray.length);
        this.trunkXCache = new Array(classesArray.length);
        this.midIndex = Math.floor(classesArray.length / 2);
      }

      positionBasedProperty(position, valueForEven, valueForOdd) {
        return position % 2 == 0 ? valueForEven : valueForOdd;
      }

      directionY(index) {
        if (this.classesArray.length % 2 == 1 && index == this.midIndex) {
          return 0;
        }
        let result = index < this.midIndex ? this.positionBasedProperty(index, -1, 1) : this.positionBasedProperty(this.classesArray.length-index-1, -1, 1);
        console.log("index=" + index + " directionY=" + result);
        return result;
      }

      directionX(index) {
        if (this.classesArray.length % 2 == 1 && index == this.midIndex) {
          return 0;
        }
        let result = index < this.midIndex ? -1 : 1;
        console.log("index=" + index + " directionX=" + result);
        return result;
      }

      pipeWidth(index) {
        return this.classesArray[index].totalCallAmount;
      }

      nodeRadius(classIndex, methodIndex) {
        return this.classesArray[classIndex].methods[methodIndex].callAmount;
      }

      maxRadius(index) {
        const classData = this.classesArray[index];
        return classData.methods.reduce((maxRadius, method, methodIndex) => Math.max(maxRadius, this.nodeRadius(index, methodIndex)), 0);
      }

      stemWidth(nodeRadius) {
        return Math.ceil(nodeRadius * 0.25);
      }

      stemLength(nodeRadius) {
        return nodeRadius * 1.5;
      }

      branchHeight(index) {
        return this.maxRadius(index) + Math.max(INIT_STEM_LENGTH, this.stemLength(this.maxRadius(index)));
      }

      maxBranchHeight(index) {
        return this.branchHeight(index) + this.pipeWidth(index);
      }

      trunkAngleCenterX(index) {
        if (this.directionY(index) < 0) {
          if (this.directionX(index) < 0) {
            return this.trunkX(index);
          } else if (this.directionX(index) > 0) {
            return this.trunkX(index) + this.pipeWidth(index);
          }
        }
        if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.trunkAngleCenterX(index-1);
          }
          if (this.directionX(index) > 0) {
            return this.trunkAngleCenterX(index+1);
          }
        }
      }

      trunkAngleCenterY(index) {
        if (this.directionY(index) < 0) {
          return this.trunkHeight(index);
        }
        if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.trunkAngleCenterY(index-1);
          }
          if (this.directionX(index) > 0) {
            return this.trunkAngleCenterY(index+1);
          }
        }
      }

      trunkAngleRadius(index) {
        if (this.directionY(index) < 0) {
          return this.pipeWidth(index);
        } else if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.pipeWidth(index) + this.pipeWidth(index-1);
          } else if (this.directionX(index) > 0) {
            return this.pipeWidth(index) + this.pipeWidth(index+1);
          }
        }
      }

      trunkX(index) {
        if (this.trunkXCache[index] !== undefined) {
          return this.trunkXCache[index];
        }

        if (index == 0) {
          this.trunkXCache[index] = Math.floor(centerX - this.classesArray.reduce((sum, classData, classIndex) => sum + this.pipeWidth(classIndex), 0) / 2);
          return this.trunkXCache[index];
        }

        this.trunkXCache[index] = this.trunkX(index-1) + this.pipeWidth(index-1);
        return this.trunkXCache[index];
      }

      trunkHeight(index) {
        if (this.trunkHeightCache[index] !== undefined) {
          return this.trunkHeightCache[index];
        }

        if (index == 0 || index == this.classesArray.length-1) {
          if (this.classesArray.length > 1) {
            this.trunkHeightCache[index] = Math.max(INITIAL_TRUNK_HEIGHT, this.maxBranchHeight(index) + FLOOR_MARGIN_VERTICAL);
          } else if (this.classesArray.length == 1) {
            this.trunkHeightCache[index] = INITIAL_TRUNK_HEIGHT;
          }
          return this.trunkHeightCache[index];
        }

        if (this.directionY(index) < 0) {
          if (this.directionX(index) < 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index-2) + this.pipeWidth(index-2) + this.maxBranchHeight(index-1) + this.maxBranchHeight(index) + FLOOR_MARGIN_VERTICAL;
          } else if (this.directionX(index) > 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index+2) + this.pipeWidth(index+2) + this.maxBranchHeight(index+1) + this.maxBranchHeight(index) + FLOOR_MARGIN_VERTICAL;
          }
        } else if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index-1);
          } else if (this.directionX(index) > 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index+1);
          }
        } else {
          this.trunkHeightCache[index] = Math.max(this.trunkHeight(index-1), this.trunkHeight(index+1));
        }

        return this.trunkHeightCache[index];
      }

      branchStartY(index) {
        if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.trunkHeight(index) + this.pipeWidth(index-1) + this.pipeWidth(index);
          }
          if (this.directionX(index) > 0) {
            return this.trunkHeight(index) + this.pipeWidth(index+1) + this.pipeWidth(index);
          }
        }
        return this.trunkHeight(index);
      }

      branchStartX(index) {
        if (this.branchXCache[index] !== undefined) {
          return this.branchXCache[index];
        }

        if (this.directionY(index) < 0) {
          if (this.directionX(index) < 0) {
            this.branchXCache[index] = this.trunkX(index);
          } else if (this.directionX(index) > 0) {
            this.branchXCache[index] = this.trunkX(index) + this.pipeWidth(index);
          }
        } else if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            this.branchXCache[index] = this.branchStartX(index-1);
          } else if (this.directionX(index) > 0) {
            this.branchXCache[index] = this.branchStartX(index+1);
          }
        }

        return this.branchXCache[index];
      }
    }

    function getRandomColor() {
      var letters = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    function drawBranches(layer, branches) {
      for (let i = 0; i < branches.length; i++) {
        const branch = branches[i];
        for (let pipe of branch.pipes) {
          console.log(pipe);
          if (pipe.type == 'rect') {
            layer.add(new Konva.Rect({
              x: pipe.startX,
              y: pipe.startY,
              width: pipe.width,
              height: pipe.height,
              fill: pipe.color,
              scaleX: pipe.scaleX,
              scaleY: pipe.scaleY,
            }));
          } else if (pipe.type == 'arc') {
            layer.add(new Konva.Arc({
              x: pipe.centerX,
              y: pipe.centerY,
              innerRadius: pipe.radius - pipe.thickness,
              outerRadius: pipe.radius,
              angle: pipe.angle,
              fill: pipe.color,
              scaleX: pipe.scaleX,
              scaleY: pipe.scaleY,
            }));
          }
        }
        for (let leave of branch.leaves) {
          layer.add(new Konva.Rect({
            x: leave.stem.startX,
            y: leave.stem.startY,
            width: leave.stem.width,
            height: leave.stem.height,
            fill: leave.stem.color,
            scaleX: leave.stem.scaleX,
            scaleY: leave.stem.scaleY,
          }));
          layer.add(new Konva.Circle({
            x: leave.node.centerX,
            y: leave.node.centerY,
            radius: leave.node.radius,
            fill: leave.node.color,
          }));
        }
      }
    }

    function drawTrunks(layer, trunks) {
      trunks.map(trunk => {
        trunk.color = getRandomColor();
        return new Konva.Rect({
          width: trunk.width,
          height: trunk.height,
          x: trunk.leftTopX,
          y: trunk.leftTopY,
          fill: trunk.color,
          stroke: 'black',
          strokeWidth: strokeWidth,
        });
      }).forEach(rect => layer.add(rect));
    }

    function convertToVisualizationData(classesArray) {
      if (classesArray.length == 0) {
        return [];
      }
      const branches = [];
      const diagramPositioner = new CallVolumeDiagramPositioner(classesArray);
      for (let i = 0; i < classesArray.length; i++) {
        const classData = classesArray[i];
        const branchData = {
          color: getRandomColor(),
        };
        const methods = classData.methods.sort((method1, method2) => method1.callAmount - method2.callAmount);
        const pipes = [
          {
            type: 'rect',
            startX: diagramPositioner.trunkX(i),
            startY: marginTop,
            height: diagramPositioner.trunkHeight(i),
            width: diagramPositioner.pipeWidth(i),
            color: branchData.color,
          },
        ];
        const leaves = [];
       pipes.push({
          type: 'arc',
          thickness: diagramPositioner.pipeWidth(i),
          radius: diagramPositioner.trunkAngleRadius(i),
          centerX: diagramPositioner.trunkAngleCenterX(i),
          centerY: diagramPositioner.trunkAngleCenterY(i),
          angle: 90,
          color: branchData.color,
          scaleX: -1 * diagramPositioner.directionX(i), // 1 to draw arc to left, -1 to draw to right
        });
        currentPositionX = diagramPositioner.branchStartX(i);
        branchStartingPositionY = diagramPositioner.branchStartY(i);
        let branchStartingPositionX = diagramPositioner.branchStartX(i);
        let directionX = diagramPositioner.directionX(i);
        let directionY = diagramPositioner.directionY(i);
        for ( let m = 0; m < methods.length; m++ ) {
          const method = methods[m];
          leaves.push({
            data: {
              name: method.name,
            },
            stem: {
              type: 'rect',
              startX: Math.ceil(currentPositionX + (circleMarginX + diagramPositioner.nodeRadius(i, m) + diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, m))/2) * diagramPositioner.directionX(i)),
              startY: diagramPositioner.branchStartY(i),
              width: diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, m)),
              height: diagramPositioner.stemLength(diagramPositioner.nodeRadius(i, m)),
              color: branchData.color,
              scaleX: -1 * diagramPositioner.directionX(i),
              scaleY: diagramPositioner.directionY(i),
            },
            node: {
              type: 'circle',
              centerX: currentPositionX + (circleMarginX + diagramPositioner.nodeRadius(i, m)) * diagramPositioner.directionX(i),
              centerY: diagramPositioner.branchStartY(i) - 0.1 * diagramPositioner.stemLength(i) * diagramPositioner.directionY(i) + (diagramPositioner.nodeRadius(i, m) + diagramPositioner.stemLength(diagramPositioner.nodeRadius(i, m))) * diagramPositioner.directionY(i),
              radius: method.callAmount,
              color: branchData.color,
            },
          });
          currentPositionX = currentPositionX + (circleMarginX + diagramPositioner.nodeRadius(i, m)) * 2 * diagramPositioner.directionX(i);
        }
        currentPositionX = Math.ceil(currentPositionX - (circleMarginX + diagramPositioner.nodeRadius(i, methods.length-1) + diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1))/2) * directionX);
        pipes.push({
          type: 'rect',
          startX: diagramPositioner.branchStartX(i),
          startY: diagramPositioner.branchStartY(i),
          width: (currentPositionX - branchStartingPositionX) * directionX,
          height: diagramPositioner.pipeWidth(i),
          color: branchData.color,
          scaleX: diagramPositioner.directionX(i),
          scaleY: -1 * diagramPositioner.directionY(i),
        });
        pipes.push({
          type: 'arc',
          thickness: diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1)),
          radius: diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1)),
          centerX: currentPositionX,
          centerY: diagramPositioner.branchStartY(i),
          angle: 90,
          color: branchData.color,
          scaleX: diagramPositioner.directionX(i), // 1 to draw arc to left, -1 to draw to right
          scaleY: -(diagramPositioner.pipeWidth(i) / diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1))) * diagramPositioner.directionY(i),
        });
        /*pipes.push({
          type: 'arc',
          thickness: classData.totalCallAmount,
          radius: classData.totalCallAmount,
          centerX: currentPositionX,
          centerY: branchStartingPositionY + (floor.vertical == 'down' ? classData.totalCallAmount : 0),
          angle: 90,
          color: branchData.color,
          scaleX: directionX, // 1 to draw arc to left, -1 to draw to right,
          scaleY: floor.vertical == 'up' ? 1 : -1, // 1 to draw down, -1 to draw up
        });*/
        //currentPositionX = pipes[0].startX + pipes[0].width;
        branches.push({
          data: branchData,
          pipes: pipes,
          leaves: leaves,
        });
    }
    return branches;
  }

    const data = [
    {
        "class": "BrewState",
        "methods": [
            {
                "callAmount": 1,
                "method": "decode(json:)"
            },
            {
                "callAmount": 0,
                "method": "create(name:)"
            }
        ],
        "totalCallAmount": 1
    },
    {
        "class": "JSONDecodable",
        "methods": [
            {
                "callAmount": 2,
                "method": "decode(json:)"
            }
        ],
        "totalCallAmount": 2
    },
    {
        "class": "BrewCell",
        "methods": [
            {
                "callAmount": 4,
                "method": "setTextColorForAllLabels(color:)"
            }
        ],
        "totalCallAmount": 4
    },
    {
        "class": "Brew",
        "methods": [
            {
                "callAmount": 9,
                "method": "decode(json:)"
            }
        ],
        "totalCallAmount": 9
    },
    {
        "class": "BrewPhase",
        "methods": [
            {
                "callAmount": 4,
                "method": "decode(json:)"
            },
            {
                "callAmount": 6,
                "method": "create(jobEnd:)"
            }
        ],
        "totalCallAmount": 10
    },
    {
        "class": "AppDelegate",
        "methods": [
            {
                "callAmount": 3,
                "method": "application(application:didFinishLaunchingWithOptions:)"
            },
            {
                "callAmount": 5,
                "method": "applicationWillResignActive(application:)"
            },
            {
                "callAmount": 6,
                "method": "applicationDidEnterBackground(application:)"
            },
            {
                "callAmount": 3,
                "method": "applicationWillEnterForeground(application:)"
            },
            {
                "callAmount": 6,
                "method": "applicationDidBecomeActive(application:)"
            },
            {
                "callAmount": 7,
                "method": "applicationWillTerminate(application:)"
            }
        ],
        "totalCallAmount": 30
    },
    {
        "class": "BrewViewController",
        "methods": [
            {
                "callAmount": 0,
                "method": "tableView(tableView:cellForRowAtIndexPath:)"
            },
            {
                "callAmount": 1,
                "method": "tableView(tableView:numberOfRowsInSection:)"
            },
            {
                "callAmount": 9,
                "method": "stateText(brewPhase:)"
            },
            {
                "callAmount": 9,
                "method": "updateStartTimeLabel()"
            },
            {
                "callAmount": 2,
                "method": "updateTempLabel(temperature:)"
            },
            {
                "callAmount": 0,
                "method": "updateNameLabel()"
            },
            {
                "callAmount": 2,
                "method": "didReceiveMemoryWarning()"
            },
            {
                "callAmount": 2,
                "method": "viewDidLoad()"
            },
            {
                "callAmount": 6,
                "method": "connectToHost()"
            }
        ],
        "totalCallAmount": 31
    }
];

    const left = [];
    const right = [];
    let mid;
    data.forEach((c, index) => {
      if (index % 2 == 0) {
        left.push(c);
      } else if (index < data.length-1) {
        right.push(c);
      } else {
        mid = c;
      }
    });
    let array = [].concat(left);
    if (mid) {
      array.push(mid);
    }
    array = array.concat(right);
    console.log(array);
    const branchesVisualData = convertToVisualizationData(array);
    console.log(branchesVisualData);
    var stage = new Konva.Stage({
      container: 'rightMenu',
      width: width,
      height: height,
    });

    var layer = new Konva.Layer();
    stage.add(layer);
    var arc = new Konva.Arc({
        x: 10,
        y: 0,
        innerRadius: 5,
        outerRadius: 10,
        angle: 90,
        scaleX: -1, // 1 to draw arc to left (default), -1 to draw to right
        fill: 'blue'
      });
      var rect = new Konva.Rect({
        x: 100,
        y: 100,
        width: 100,
        height: 50,
        scaleX: -1, //1 to draw rect to right (default), -1 to draw rect to left
        fill: 'blue'
      });
    drawBranches(layer, branchesVisualData);
    layer.add(arc);
    layer.add(rect);
    layer.draw();
    setTimeout(() => { stage.scale({x: 3, y: 3}); stage.batchDraw(); }, 200);

/*
branches: [
  {
    data: {

    },
    pipes: [
      //the first one is always trunk
      {
        type: 'rect',
        startX: 100,
        startY: 100,
        width: 80,
        height: 100,
        color: 'blue',
      },
      {
        type: 'arc',
        thickness: 5,
        radius:10,
        centerX: 200,
        centerY: 180,
        angle: 90,
        color: 'blue',
        scaleX: -1, // 1 to draw arc to left, -1 to draw to right
      },
      {
        type: 'rect',
        startX: 100,
        startY: 100,
        width: 120,
        height: 120,
        color: 'red',
      },
      // ...
    ],
    leaves: [
      {
        data: {

        },
        stem: {
          type: 'rect,
          startX: 100, //last corner in branch direction
          startY: 100,
          width: 100,
          height: 100,
          scaleX: -1,
          color: 'red',
        },
        node: {
          type: 'circle',
          centerX: 10,
          centerY: 10,
          radius: 10,
          color: 'orange',
        }
      },
      // ...
    ]
  }
]
*/
  </script>
</html>


