<html>
  <head>
    <style>
      * {
        padding: 0;
        margin: 0;
      }

      html, body, header {
        min-height: 100%;
        width: 100%;
        height: 100%;
      }
      
      #container {
        height: calc(100% - 40px);
        padding: 20px;
        position: relative;
      }

      #flexbox {
        display: flex;
        justify-content: stretch;
        flex: 0 0 0;
        height: 100%;
      }

      #leftMenu {
        background-color: #ccc;
        display: block;
        max-width: 25%;
      }

      #rightMenu {
        height: 100%;
        width: 100%;
        background-color: #ddd;
        overflow: scroll;
      }

      #selector {
        width: 0;
        height: 0;
        background-color: rgba(50, 200, 211, 0.5);
        position: absolute;
      }
    </style>
    <script src="https://unpkg.com/konva@7.0.3/konva.min.js"></script>
  </head>
  <body>
    <div id="container">
      <div id="flexbox">
        <div id="leftMenu">
        </div>
        <div id="rightMenu">
        </div>
      </div>
    </div>
    <div id="selector"></div>
  </body>
  <script>
    const scale = 5;
    const circleMarginX = 6;
    const circleMarginY = 4;
    const strokeWidth = 0;
    const pipeAngleRadius = 4;
    const floorMargin = 10;
    const stemLength = 10;
    const stemWidth = 6;
    var width = 1600;
    var height = 1000;
    const centerX = width / 5;
    const centerY = 0;
    const marginTop = 0;
    const trunkHeight = 45; //todo remove and use INITIAL_TRUNK_HEIGHT
    const INITIAL_TRUNK_HEIGHT = 45;
    const FLOOR_MARGIN_VERTICAL = 2;
    const INIT_STEM_LENGTH = 10;
    const floors = [];

    class CallVolumeDiagramPositioner {
      constructor(classesArray) {
        this.classesArray = classesArray;
        this.trunkHeightCache = new Array(classesArray.length);
        this.branchXCache = new Array(classesArray.length);
        this.trunkXCache = new Array(classesArray.length);
        this.midIndex = Math.floor(classesArray.length / 2);
        this.stemData = new Array(classesArray.length);
        for (let i = 0; i < this.stemData.length; i++){
          this.stemData[i] = new Array(this.stemData.length);
        }
      }

      positionBasedProperty(position, valueForEven, valueForOdd) {
        return position % 2 == 0 ? valueForEven : valueForOdd;
      }

      directionY(index) {
        if (this.classesArray.length % 2 == 1 && index == this.midIndex) {
          return 0;
        }
        let result = index < this.midIndex ? this.positionBasedProperty(index, -1, 1) : this.positionBasedProperty(this.classesArray.length-index-1, -1, 1);
        return result;
      }

      directionX(index) {
        if (this.classesArray.length % 2 == 1 && index == this.midIndex) {
          return 0;
        }
        let result = index < this.midIndex ? -1 : 1;
        return result;
      }

      pipeWidth(index) {
        return Math.ceil(this.classesArray[index].totalCallAmount * 0.25);
      }

      nodeRadius(classIndex, methodIndex) {
        return this.classesArray[classIndex].methods[methodIndex].callAmount;
      }

      maxRadius(index) {
        const classData = this.classesArray[index];
        return classData.methods.reduce((maxRadius, method, methodIndex) => Math.max(maxRadius, this.nodeRadius(index, methodIndex)), 0);
      }

      nodePosition(classIndex, methodIndex) {
        const stemPosition = this.stemPosition(classIndex, methodIndex);
        if (this.directionY(classIndex) == 0) {
          if (this.classesArray[classIndex].methods.length == 1) {
            return {
              centerX: stemPosition.startX + stemPosition.width/2,
              centerY: stemPosition.startY + 0.9 * stemPosition.height + this.nodeRadius(classIndex, methodIndex),
              radius: this.nodeRadius(classIndex, methodIndex),
            };
          }
          if (this.classesArray[classIndex].methods.length > 0) {
            return {
              centerX: stemPosition.startX + 0.9 * stemPosition.width * (methodIndex % 2 == 0 ? -1 : 1),
              centerY: stemPosition.startY + stemPosition.height / 2,
              radius: this.nodeRadius(classIndex, methodIndex),
            }
          }
        }
        return {
          centerX: stemPosition.startX + stemPosition.width / 2 * this.directionX(classIndex),
          centerY: this.branchStartY(classIndex) + (0.9 * stemPosition.height + this.nodeRadius(classIndex, methodIndex)) * this.directionY(classIndex),
          radius: this.nodeRadius(classIndex, methodIndex),
        };
      }

      stemPosition(classIndex, methodIndex) {
        if (this.stemData[classIndex][methodIndex] !== undefined) {
          return this.stemData[classIndex][methodIndex];
        }
        
        if (methodIndex == 0) {
          if (this.directionX(classIndex) == 0) {
            if (this.classesArray[classIndex].methods.length == 1) {
              this.stemData[classIndex][methodIndex] = {
                startX: this.branchStartX(classIndex),
                startY: this.branchStartY(classIndex),
                width: this.stemWidthFor(classIndex, methodIndex),
                height: this.stemLengthFor(classIndex, methodIndex),
              };
            } else if (this.classesArray[classIndex].methods.length > 0) {
              this.stemData[classIndex][methodIndex] = {
                startX: this.branchStartX(classIndex),
                startY: this.branchStartY(classIndex) + this.nodeRadius(classIndex, methodIndex),
                width: this.stemLengthFor(classIndex, methodIndex),
                height: this.stemWidthFor(classIndex, methodIndex),
                scaleX: -1,
              };
            }
          } else {
            this.stemData[classIndex][methodIndex] = {
              startX: this.branchStartX(classIndex) + (circleMarginX + this.nodeRadius(classIndex, methodIndex)) * this.directionX(classIndex),
              startY: this.branchStartY(classIndex),
              width: this.stemWidthFor(classIndex, methodIndex),
              height: this.stemLengthFor(classIndex, methodIndex),
              scaleX: this.directionX(classIndex),
              scaleY: this.directionY(classIndex),
            };
          }
        } else if (methodIndex > 0) {
          if (this.directionX(classIndex) == 0) {
            this.stemData[classIndex][methodIndex] = {
              startX: this.branchStartX(classIndex) + (methodIndex % 2 == 1 ? + this.pipeWidth(classIndex) : 0),
              startY: (methodIndex == 1 ? this.stemPosition(classIndex, methodIndex-1).startY + FLOOR_MARGIN_VERTICAL : this.stemPosition(classIndex, methodIndex-2).startY + this.stemPosition(classIndex, methodIndex-2).height/2 + this.nodeRadius(classIndex, methodIndex-2) + FLOOR_MARGIN_VERTICAL + this.nodeRadius(classIndex, methodIndex) - this.stemWidthFor(classIndex, methodIndex)/2.0),
              width: this.stemLengthFor(classIndex, methodIndex),
              height: this.stemWidthFor(classIndex, methodIndex),
              scaleX: methodIndex % 2 == 0 ? -1 : 1,
            };
          } else {
            this.stemData[classIndex][methodIndex] = {
              startX: this.stemPosition(classIndex, methodIndex-1).startX + (this.stemPosition(classIndex, methodIndex-1).width / 2.0 + this.nodeRadius(classIndex, methodIndex-1) + 2 * circleMarginX + this.nodeRadius(classIndex, methodIndex) - this.stemWidthFor(classIndex, methodIndex) / 2.0) * this.directionX(classIndex),
              startY: this.branchStartY(classIndex),
              width: this.stemWidthFor(classIndex, methodIndex),
              height: this.stemLengthFor(classIndex, methodIndex),
              scaleX: this.directionX(classIndex),
              scaleY: this.directionY(classIndex),
            };
          }
        }
        return this.stemData[classIndex][methodIndex];
      }

      stemWidthFor(classIndex, methodIndex) {
        return this.stemWidth(this.nodeRadius(classIndex, methodIndex));
      }

      stemWidth(nodeRadius) {
        return Math.ceil(nodeRadius * 0.25);
      }

      stemLengthFor(classIndex, methodIndex) {
        return this.stemLength(this.nodeRadius(classIndex, methodIndex));
      }

      stemLength(nodeRadius) {
        return Math.ceil(nodeRadius * 1.5);
      }

      branchHeight(index) {
        return 2 * this.maxRadius(index) + this.stemLength(this.maxRadius(index));
      }

      maxBranchHeight(index) {
        return this.branchHeight(index) + this.pipeWidth(index);
      }

      trunkAngleCenterX(index) {
        if (this.directionY(index) < 0) {
          if (this.directionX(index) < 0) {
            return this.trunkX(index);
          } else if (this.directionX(index) > 0) {
            return this.trunkX(index) + this.pipeWidth(index);
          }
        }
        if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.trunkAngleCenterX(index-1);
          }
          if (this.directionX(index) > 0) {
            return this.trunkAngleCenterX(index+1);
          }
        }
      }

      trunkAngleCenterY(index) {
        if (this.directionY(index) < 0) {
          return this.trunkHeight(index);
        }
        if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.trunkAngleCenterY(index-1);
          }
          if (this.directionX(index) > 0) {
            return this.trunkAngleCenterY(index+1);
          }
        }
      }

      trunkAngleRadius(index) {
        if (this.directionY(index) < 0) {
          return this.pipeWidth(index);
        } else if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.pipeWidth(index) + this.pipeWidth(index-1);
          } else if (this.directionX(index) > 0) {
            return this.pipeWidth(index) + this.pipeWidth(index+1);
          }
        }
      }

      trunkX(index) {
        if (this.trunkXCache[index] !== undefined) {
          return this.trunkXCache[index];
        }

        if (index == 0) {
          this.trunkXCache[index] = Math.floor(centerX - this.classesArray.reduce((sum, classData, classIndex) => sum + this.pipeWidth(classIndex), 0) / 2);
          return this.trunkXCache[index];
        }

        this.trunkXCache[index] = this.trunkX(index-1) + this.pipeWidth(index-1);
        return this.trunkXCache[index];
      }

      trunkHeight(index) {
        if (this.trunkHeightCache[index] !== undefined) {
          return this.trunkHeightCache[index];
        }

        if (index == 0 || index == this.classesArray.length-1) {
          if (this.classesArray.length > 1) {
            this.trunkHeightCache[index] = Math.max(INITIAL_TRUNK_HEIGHT, this.maxBranchHeight(index) + FLOOR_MARGIN_VERTICAL);
          } else if (this.classesArray.length == 1) {
            this.trunkHeightCache[index] = INITIAL_TRUNK_HEIGHT;
          }
          return this.trunkHeightCache[index];
        }

        if (this.directionY(index) < 0) {
          if (this.directionX(index) < 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index-2) + this.pipeWidth(index-2) + this.maxBranchHeight(index-1) + this.maxBranchHeight(index) + FLOOR_MARGIN_VERTICAL;
          } else if (this.directionX(index) > 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index+2) + this.pipeWidth(index+2) + this.maxBranchHeight(index+1) + this.maxBranchHeight(index) + FLOOR_MARGIN_VERTICAL;
          }
        } else if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index-1);
          } else if (this.directionX(index) > 0) {
            this.trunkHeightCache[index] = this.trunkHeight(index+1);
          }
        } else {
          let leftBranchHeight = this.trunkHeight(index-1) + (this.directionY(index-1) > 0 ? this.maxBranchHeight(index-1) : this.pipeWidth(index-1));
          let rightBranchHeight = this.trunkHeight(index+1) + (this.directionY(index+1) > 0 ? this.maxBranchHeight(index+1) : this.pipeWidth(index+1));
          this.trunkHeightCache[index] = Math.max(leftBranchHeight, rightBranchHeight) + FLOOR_MARGIN_VERTICAL;
        }

        return this.trunkHeightCache[index];
      }

      branchStartY(index) {
        if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            return this.trunkHeight(index) + this.pipeWidth(index-1) + this.pipeWidth(index);
          }
          if (this.directionX(index) > 0) {
            return this.trunkHeight(index) + this.pipeWidth(index+1) + this.pipeWidth(index);
          }
        }
        return this.trunkHeight(index);
      }

      branchStartX(index) {
        if (this.branchXCache[index] !== undefined) {
          return this.branchXCache[index];
        }

        if (this.directionY(index) < 0) {
          if (this.directionX(index) < 0) {
            this.branchXCache[index] = this.trunkX(index);
          } else if (this.directionX(index) > 0) {
            this.branchXCache[index] = this.trunkX(index) + this.pipeWidth(index);
          }
        } else if (this.directionY(index) > 0) {
          if (this.directionX(index) < 0) {
            this.branchXCache[index] = this.branchStartX(index-1);
          } else if (this.directionX(index) > 0) {
            this.branchXCache[index] = this.branchStartX(index+1);
          }
        } else {
          this.branchXCache[index] = this.trunkX(index);
        }

        return this.branchXCache[index];
      }
    }

    function getRandomColor() {
      var letters = '0123456789ABCDEF';
      var color = '#';
      for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    function drawBranches(layer, branches) {
      for (let i = 0; i < branches.length; i++) {
        const branch = branches[i];
        for (let pipe of branch.pipes) {
          console.log(pipe);
          if (pipe.type == 'rect') {
            layer.add(new Konva.Rect({
              x: pipe.startX,
              y: pipe.startY,
              width: pipe.width,
              height: pipe.height,
              fill: pipe.color,
              scaleX: pipe.scaleX,
              scaleY: pipe.scaleY,
            }));
          } else if (pipe.type == 'arc') {
            layer.add(new Konva.Arc({
              x: pipe.centerX,
              y: pipe.centerY,
              innerRadius: pipe.radius - pipe.thickness,
              outerRadius: pipe.radius,
              angle: pipe.angle,
              fill: pipe.color,
              scaleX: pipe.scaleX,
              scaleY: pipe.scaleY,
            }));
          }
        }
        for (let leave of branch.leaves) {
          layer.add(new Konva.Rect({
            x: leave.stem.startX,
            y: leave.stem.startY,
            width: leave.stem.width,
            height: leave.stem.height,
            fill: leave.stem.color,
            scaleX: leave.stem.scaleX,
            scaleY: leave.stem.scaleY,
          }));
          layer.add(new Konva.Circle({
            x: leave.node.centerX,
            y: leave.node.centerY,
            radius: leave.node.radius,
            fill: leave.node.color,
          }));
        }
      }
    }

    function drawTrunks(layer, trunks) {
      trunks.map(trunk => {
        trunk.color = getRandomColor();
        return new Konva.Rect({
          width: trunk.width,
          height: trunk.height,
          x: trunk.leftTopX,
          y: trunk.leftTopY,
          fill: trunk.color,
          stroke: 'black',
          strokeWidth: strokeWidth,
        });
      }).forEach(rect => layer.add(rect));
    }

    function shuffle(array) {
      var currentIndex = array.length, temporaryValue, randomIndex;

      // While there remain elements to shuffle...
      while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }

      return array;
    }

    function convertToVisualizationData(classesArray) {
      if (classesArray.length == 0) {
        return [];
      }
      const branches = [];
      const diagramPositioner = new CallVolumeDiagramPositioner(classesArray);
      window.diagramPositioner = diagramPositioner;
      for (let i = 0; i < classesArray.length; i++) {
        const classData = classesArray[i];
        const branchData = {
          color: getRandomColor(),
        };
        const methods = classData.methods.sort((method1, method2) => method1.callAmount - method2.callAmount);
        const pipes = [
          {
            type: 'rect',
            startX: diagramPositioner.trunkX(i),
            startY: marginTop,
            height: diagramPositioner.trunkHeight(i),
            width: diagramPositioner.pipeWidth(i),
            color: branchData.color,
          },
        ];
        const leaves = [];
        currentPositionX = diagramPositioner.branchStartX(i);
        branchStartingPositionY = diagramPositioner.branchStartY(i);
        let branchStartingPositionX = diagramPositioner.branchStartX(i);
        let directionX = diagramPositioner.directionX(i);
        let directionY = diagramPositioner.directionY(i);
        for ( let m = 0; m < methods.length; m++ ) {
          const method = methods[m];
          leaves.push({
            data: {
              name: method.name,
            },
            stem: {
              type: 'rect',
              color: branchData.color,
              ...diagramPositioner.stemPosition(i, m),
            },
            node: {
              type: 'circle',
              color: branchData.color,
              ...diagramPositioner.nodePosition(i, m),
            },
          });
        }
        if (diagramPositioner.directionY(i) == 0) {
          pipes.push({
            type: 'rect',
            startX: diagramPositioner.branchStartX(i),
            startY: diagramPositioner.branchStartY(i),
            width: diagramPositioner.pipeWidth(i),
            height: diagramPositioner.stemPosition(i, methods.length-1).startY - diagramPositioner.branchStartY(i),
            color: branchData.color,
            scaleY: 1,
          });
          pipes.push({
            type: 'arc',
            thickness: diagramPositioner.stemWidthFor(i, methods.length-1),
            radius: diagramPositioner.stemWidthFor(i, methods.length-1),
            centerX: diagramPositioner.stemPosition(i, methods.length-1).startX,
            centerY: diagramPositioner.stemPosition(i, methods.length-1).startY,
            angle: 90,
            color: branchData.color,
            scaleX: -1 * ((methods.length-1) % 2 == 0 ? -1 : 1) * (diagramPositioner.pipeWidth(i) / diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1))), // 1 to draw arc to left, -1 to draw to right
            scaleY: 1,
          });
        } else {
          pipes.push({
            type: 'arc',
            thickness: diagramPositioner.pipeWidth(i),
            radius: diagramPositioner.trunkAngleRadius(i),
            centerX: diagramPositioner.trunkAngleCenterX(i),
            centerY: diagramPositioner.trunkAngleCenterY(i),
            angle: 90,
            color: branchData.color,
            scaleX: -1 * diagramPositioner.directionX(i), // 1 to draw arc to left, -1 to draw to right
          });
          pipes.push({
            type: 'rect',
            startX: diagramPositioner.branchStartX(i),
            startY: diagramPositioner.branchStartY(i),
            width: (diagramPositioner.stemPosition(i, methods.length-1).startX - branchStartingPositionX) * diagramPositioner.directionX(i),
            height: diagramPositioner.pipeWidth(i),
            color: branchData.color,
            scaleX: diagramPositioner.directionX(i),
            scaleY: -1 * diagramPositioner.directionY(i),
          });
          pipes.push({
            type: 'arc',
            thickness: diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1)),
            radius: diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1)),
            centerX: diagramPositioner.stemPosition(i, methods.length-1).startX,
            centerY: diagramPositioner.branchStartY(i),
            angle: 90,
            color: branchData.color,
            scaleX: diagramPositioner.directionX(i), // 1 to draw arc to left, -1 to draw to right
            scaleY: -(diagramPositioner.pipeWidth(i) / diagramPositioner.stemWidth(diagramPositioner.nodeRadius(i, methods.length-1))) * diagramPositioner.directionY(i),
          });
        }
        branches.push({
          data: branchData,
          pipes: pipes,
          leaves: leaves,
        });
    }
    return branches;
  }

    const data = [
    {
        "class": "BrewState",
        "methods": [
            {
                "callAmount": 1,
                "method": "decode(json:)"
            },
        ],
        "totalCallAmount": 1
    },
    {
        "class": "BrewCell",
        "methods": [
            {
                "callAmount": 4,
                "method": "setTextColorForAllLabels(color:)"
            }
        ],
        "totalCallAmount": 4
    },
    {
        "class": "Brew",
        "methods": [
            {
                "callAmount": 9,
                "method": "decode(json:)"
            }
        ],
        "totalCallAmount": 9
    },
    {
        "class": "BrewViewController",
        "methods": [
            {
                "callAmount": 1,
                "method": "tableView(tableView:numberOfRowsInSection:)"
            },
            {
                "callAmount": 9,
                "method": "stateText(brewPhase:)"
            },
            {
                "callAmount": 9,
                "method": "updateStartTimeLabel()"
            },
            {
                "callAmount": 2,
                "method": "updateTempLabel(temperature:)"
            },
            {
                "callAmount": 2,
                "method": "didReceiveMemoryWarning()"
            },
            {
                "callAmount": 2,
                "method": "viewDidLoad()"
            },
            {
                "callAmount": 6,
                "method": "connectToHost()"
            }
        ],
        "totalCallAmount": 31
    },
    {
        "class": "AppDelegate",
        "methods": [
            {
                "callAmount": 3,
                "method": "application(application:didFinishLaunchingWithOptions:)"
            },
            {
                "callAmount": 5,
                "method": "applicationWillResignActive(application:)"
            },
            {
                "callAmount": 6,
                "method": "applicationDidEnterBackground(application:)"
            },
            {
                "callAmount": 3,
                "method": "applicationWillEnterForeground(application:)"
            },
            {
                "callAmount": 6,
                "method": "applicationDidBecomeActive(application:)"
            },
            {
                "callAmount": 7,
                "method": "applicationWillTerminate(application:)"
            }
        ],
        "totalCallAmount": 30
    },
    {
        "class": "BrewPhase",
        "methods": [
            {
                "callAmount": 4,
                "method": "decode(json:)"
            },
            {
                "callAmount": 6,
                "method": "create(jobEnd:)"
            }
        ],
        "totalCallAmount": 10
    },
    {
        "class": "JSONDecodable",
        "methods": [
            {
                "callAmount": 2,
                "method": "decode(json:)"
            }
        ],
        "totalCallAmount": 2
    },
];

    const left = [];
    const right = [];
    let mid;
    /*data.forEach((c, index) => {
      if (index % 2 == 0) {
        left.push(c);
      } else if (index < data.length-1) {
        right.push(c);
      } else {
        mid = c;
      }
    });
    let array = [].concat(left);
    if (mid) {
      array.push(mid);
    }
    array = array.concat(right);
    //array = shuffle(array);*/
    array = data;
    console.log(array);
    const branchesVisualData = convertToVisualizationData(array);
    console.log(branchesVisualData);
    var stage = new Konva.Stage({
      container: 'rightMenu',
      width: width,
      height: height,
    });

    var layer = new Konva.Layer();
    stage.add(layer);
    var arc = new Konva.Arc({
        x: 10,
        y: 0,
        innerRadius: 5,
        outerRadius: 10,
        angle: 90,
        scaleX: -1, // 1 to draw arc to left (default), -1 to draw to right
        fill: 'blue'
      });
      var rect = new Konva.Rect({
        x: 100,
        y: 100,
        width: 100,
        height: 50,
        scaleX: -1, //1 to draw rect to right (default), -1 to draw rect to left
        fill: 'blue'
      });
    drawBranches(layer, branchesVisualData);
    stage.scale({x: 3, y: 3});
    layer.add(arc);
    layer.add(rect);
    layer.draw();

/*
branches: [
  {
    data: {

    },
    pipes: [
      //the first one is always trunk
      {
        type: 'rect',
        startX: 100,
        startY: 100,
        width: 80,
        height: 100,
        color: 'blue',
      },
      {
        type: 'arc',
        thickness: 5,
        radius:10,
        centerX: 200,
        centerY: 180,
        angle: 90,
        color: 'blue',
        scaleX: -1, // 1 to draw arc to left, -1 to draw to right
      },
      {
        type: 'rect',
        startX: 100,
        startY: 100,
        width: 120,
        height: 120,
        color: 'red',
      },
      // ...
    ],
    leaves: [
      {
        data: {

        },
        stem: {
          type: 'rect,
          startX: 100, //last corner in branch direction
          startY: 100,
          width: 100,
          height: 100,
          scaleX: -1,
          color: 'red',
        },
        node: {
          type: 'circle',
          centerX: 10,
          centerY: 10,
          radius: 10,
          color: 'orange',
        }
      },
      // ...
    ]
  }
]
*/
  </script>
</html>


